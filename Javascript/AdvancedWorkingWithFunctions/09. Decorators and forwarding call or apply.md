# **Decorators and forwarding, call/apply** ((link resource)[https://javascript.info/call-apply-decorators])

## **Transparent caching**

Let's say we have a function <code>slow(x)</code> which is CPU-heavy, but its results are stable. In other words, for the same <code>x</code> it always returns the same result.

If the function is called often, we may want to cache (remember) the result to avoid spending extra-time on recalculations.

But instead of adding that functionality into show() we'll create a wrapper function, that adds caching. As we'll see, there are many benefits of doing so.

```javascript
function slow(x) {
	// there can be a heavy CPU-intensive job here
	alert(`Called with ${x}`);
	return x;
}

function cachingDecorator(func) {
	let cache = new Map();

	return function (x) {
		if (cache.has(x)) {
			// if there's such key in cache
			return cache.get(x); // read the result from it
		}

		let result = func(x); // otherwise call func

		cache.set(x, result); // and cache (remember) the result
		return result;
	};
}

slow = cachingDecorator(slow);

alert(slow(1)); // slow(1) is cached and the result returned
alert("Again: " + slow(1)); // slow(1) result returned from cache

alert(slow(2)); // slow(2) is cached and the result returned
alert("Again: " + slow(2)); // slow(2) result returned from cache
```

## **Using "func.call" for the context**

The caching decorator mentioned above is not suited to work with object methods.

```javascript
// we'll make worker.slow caching
let worker = {
	someMethod() {
		return 1;
	},

	slow(x) {
		// scary CPU-heavy task here
		alert("Called with " + x);
		return x * this.someMethod(); // (*)
	},
};

// same code as before
function cachingDecorator(func) {
	let cache = new Map();
	return function (x) {
		if (cache.has(x)) {
			return cache.get(x);
		}
		let result = func(x); // (**)
		cache.set(x, result);
		return result;
	};
}

alert(worker.slow(1)); // the original method works

worker.slow = cachingDecorator(worker.slow); // now make it caching

alert(worker.slow(2)); // Whoops! Error: Cannot read property 'someMethod' of undefined
```

The error occurs in the line <code>(\*)</code> that tries to access <code>this.someMethod</code> and fails. Can you see why?

The reason is that wrapped calls the original functions as <code>func(x)</code> in the line <code>(\*\*)</code>. And, when called like that, the function gets <code>this = undefined</code>.

We would observe a similar symptom if we tried to run:

```javascript
let func = worker.slow;
func(2);
```

So, the wrapper passes the call to the original method, but without the context <code>this</code>. Hence the error.

Let's fix it.

There's a special built-in function method <code>func.call(context,...args)</code> that allows to call a function explicitly setting <code>this</code>.

```javascript
func.call(context, arg1, arg2, ...)
```

To put it simply, these two calls do almost the same:

```javascript
func(1, 2, 3);
func.call(obj, 1, 2, 3);
```

They both call <code>func</code> with arguments <code>1</code>, <code>2</code>, and <code>3</code>. The only difference is that <code>func.call</code> also sets <code>this</code> to <code>obj</code>.

```javascript
let worker = {
	someMethod() {
		return 1;
	},

	slow(x) {
		alert("Called with " + x);
		return x * this.someMethod(); // (*)
	},
};

function cachingDecorator(func) {
	let cache = new Map();
	return function (x) {
		if (cache.has(x)) {
			return cache.get(x);
		}
		let result = func.call(this, x); // "this" is passed correctly now
		cache.set(x, result);
		return result;
	};
}

worker.slow = cachingDecorator(worker.slow); // now make it caching

alert(worker.slow(2)); // works
alert(worker.slow(2)); // works, doesn't call the original (cached)
```

Now everything is fine:

To make it all clear, let's see more deeply how <code>this</code> is passed along:

1. After the decoration <code>worker.slow</code> is now the wrapper <code>function (x) {...}</code>.

2. So when <code>worker.slow(2)</code> is executed, the wrapper gets <code>2</code> as an argument and <code>this=worker</code>.

3. Inside the wrapper, assuming the result is not yet cached, <code>func.call(this, x)</code> passes the current <code>this</code>(<code>=worker</code>) and then current argument (<code>=2</code>) to the original method.

## **Going multi-argument**
